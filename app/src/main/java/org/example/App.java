/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;

import static java.lang.Math.exp;
import static java.lang.Math.pow;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ThreadLocalRandom;
import java.util.function.DoubleSupplier;
import java.util.function.DoubleToLongFunction;
import java.util.function.LongToDoubleFunction;
import java.util.function.LongToIntFunction;
import java.util.stream.Collectors;
import java.util.stream.DoubleStream;

public class App {

  public static long factorial(long number) {
    long result = 1;
    for (int factor = 2; factor <= number; factor++) {
      result *= factor;
    }
    return result;
  }

  /**
   * Левый интервал включительно, правый нет
   * 
   * @param a
   * @param b
   */
  record Range(long a, long b, double prob) {

  };

  public static void main(String[] args) {

    // Вариант 9.

    final long N = 1000; // Размер выборки
    final double n = 11; // Число интервалов
    final double alpha = 9; // Параметр распределения

    if (n < 2 || n > 20)
      throw new IllegalArgumentException("Недопустимое число интервалов");

    // Источник исходного материала R с равномерным распределением от 0 до 1
    DoubleSupplier supplier = () -> ThreadLocalRandom.current().nextDouble();

    // Функция плотности распределения вероятностей
    // probability density function
    // Узнать вероятность конкретного исхода
    LongToDoubleFunction densityFunction = (long x) -> pow(alpha, x) / factorial(x) * exp(-alpha);

    DoubleToLongFunction reverseDensityFuntion = (double x) -> {
      int k = 0;
      double right = densityFunction.applyAsDouble(k);
      while (x > right)
        right += densityFunction.applyAsDouble(++k);
      return k;
    };

    // Получение интервалов

    List<Range> ranges = new ArrayList<>();

    double targetProb = 1 / n;
    System.out.println("Target prob " + targetProb);
    double summaryProb = 0;
    int a = 0;
    int b = 0;
    while (ranges.size() != n) {

      double rangeProb = densityFunction.applyAsDouble(a);

      while (rangeProb < targetProb)
        rangeProb += densityFunction.applyAsDouble(++b);
      ranges.add(new Range(a, b + 1, rangeProb));
      // System.out.println(ranges.getLast());
      summaryProb += ranges.getLast().prob();

      if (1 - summaryProb < targetProb) {
        ranges.add(new Range(b, Long.MAX_VALUE, 1 - summaryProb));
        // System.out.println(ranges.getLast());
        summaryProb += ranges.getLast().prob();
        break;
      }
      a = b + 1;
      b = a;
    }

    // Чистка интервалов

    while (ranges.getLast().prob() < 0.05) {
      var last = ranges.removeLast();
      var prevLast = ranges.removeLast();
      ranges.add(new Range(prevLast.a(), last.b(), last.prob() + prevLast.prob()));
    }

    String rangesReport = ranges.stream().map(Object::toString).collect(Collectors.joining("\n"));
    System.out.println(rangesReport);

    LongToIntFunction valueToIntervalIndexF = (long x) -> {
      int index = 0;
      for (;;) {
        var r = ranges.get(index);
        if (r.a() <= x && r.b() > x)
          break;
        index++;
      }
      return index;
    };

    // var s = DoubleStream.generate(supplier) // тут double 0...1
    // .mapToLong(reverseDensityFuntion)
    // .limit(N)
    // .boxed()
    // .collect(Collectors.toList()); // тут long 0...inf

    // var map1 = s.stream()
    // .collect(Collectors.groupingBy(x -> x, Collectors.counting()));

    // var map2 = s.stream()// тут double 0...1
    // .mapToLong(Long::valueOf)
    // .mapToInt(valueToIntervalIndexF) // тут int 0...n
    // .boxed()

    // System.out.println(map1);
    // System.out.println(map2);

    var realFreq = DoubleStream.generate(supplier) // тут double 0...1
        .mapToLong(reverseDensityFuntion)
        .mapToInt(valueToIntervalIndexF) // тут int 0...n
        .boxed()
        .limit(N)
        .collect(Collectors.groupingBy(x -> x, Collectors.counting()))
        .entrySet().stream()
        .map(entry -> entry.getValue())
        .collect(Collectors.toList()); // тут long 0...inf

    var expectedFreq = ranges.stream()
        .map(Range::prob)
        .map(prob -> (long) (prob * N))
        .collect(Collectors.toList());

    double hi = 0;
    for (int i = 0; i < realFreq.size(); i++)
      hi += pow(realFreq.get(i) - expectedFreq.get(i), 2) / expectedFreq.get(i);

    System.out.println(realFreq);
    System.out.println(expectedFreq);
    System.out.println("Хи квадрат: "  + hi);
    // System.out.println(map);
  }
}
